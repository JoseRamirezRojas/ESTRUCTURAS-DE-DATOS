package practica6;//import java.util.function.Consumer;/** * Implementación de árboles rojinegros. */public class ArbolRojinegro<T extends Comparable<T>> extends ArbolBinarioBusqueda<T>{    /**     * Clase protegida de Vértice Rojinegro     */    protected class VerticeRojinegro extends Vertice{        public Color color;        /**         * Constructor de un vértice rojinegro, heredado de un vértice normal.         * @param elemento Elemento del vértice rojinegro         */        public VerticeRojinegro(T elemento){            // Aquí va su código.            super(elemento);            if(elemento==null){                this.color=color.NEGRO;            }            this.color= color.ROJO;        }    }    /**     * Constructor vacío de árbol rojinegro     */    public ArbolRojinegro(){        super();    }    /**     * Constructor a partir de un arreglo de un Árbol Rojinegro     *     * @param a Arreglo de elementos para construir el árbol rojinegro     */    public ArbolRojinegro(T[] a){        super(a);    }    /**     * Toman una instancia de Vertice y obtiene su color.     * @param v Vértice recibido.     */    protected Color getColor(Vertice v){        if (v instanceof ArbolRojinegro.VerticeRojinegro)            return ((VerticeRojinegro) v).color;        return Color.ROJO;    }//    /**//     * Imprime el color de cada vértice del árbol rojinegro//     * @param funcion Vértice rojinegro del que imprimimos su color//     *///    protected void colorBFS(Consumer<T> funcion){//        VerticeRojinegro u=new VerticeRojinegro(raiz.elemento);//        if(u!=null){//            Cola<VerticeRojinegro> cola=new Cola<>();//            cola.mete(u);//            while (!cola.esVacia()){//                VerticeRojinegro v=cola.mira();//                if (v.izquierdo!=null)//                    cola.mete((VerticeRojinegro) v.izquierdo);//                if (v.derecho!=null)//                    cola.mete((VerticeRojinegro) v.derecho);//                System.out.print(v.elemento);//                System.out.println(v.color.toString());//                cola.saca();//            }//        }//    }    /**     * Imprime el color de cada vértice del árbol rojinegro     * @param v Vértice rojinegro del que imprimimos su color     */    protected void imprimeRojinegroColorInOrder(VerticeRojinegro v) {        if(v!=null){            imprimeRojinegroColorInOrder((VerticeRojinegro) v.izquierdo);            System.out.print(v.elemento);            System.out.print("\t"+v.color.toString());            imprimeRojinegroColorInOrder((VerticeRojinegro) v.derecho);        }    }    protected void imprimeRojinegroColorInOrder() {        imprimeRojinegroColorInOrder ((VerticeRojinegro)raiz);    }    /**     * Toman una instancia de Vertice y le asigna un color.     * @param v Vértice recibido.     * @param c Color a asignar al vértice.     */    protected void setColor(Vertice v, Color c){        if(v instanceof ArbolRojinegro.VerticeRojinegro)            ((VerticeRojinegro) v).color=c;    }    /**     * Agrega un elemento a un árbol rojinegro.     * @param elemento Elemento a agregar     */    @Override    public void agrega(T elemento){        VerticeRojinegro v=new VerticeRojinegro(elemento);        elementos++;        if (raiz==null) {            raiz = v;            balanceaAgrega(v);            return;        }        agregaRecursivo(raiz,v);        balanceaAgrega(v);    }    /**     * Algoritmo recursivo para balancear un árbol rojinegro al agregarle un vértice     * @param v  Vértice agreado al árbol     */    public void balanceaAgrega(Vertice v) {        //caso 1: El vértice no tiene padre, i.e. es raíz        if (v == raiz){            setColor(v,Color.NEGRO);            return;        }        Vertice p=v.padre;        //caso 2: El padre es negro        if (getColor(p)==Color.NEGRO)            return;        Vertice a=p.padre;        Vertice t;        //caso 3: El tío es rojo        if (p.padre.derecho == p) {            t = a.izquierdo;            if (getColor(t)==Color.ROJO) {                if (t != null) {                    setColor(p, Color.NEGRO);                    setColor(t, Color.NEGRO);                    setColor(a, Color.ROJO);                    balanceaAgrega(a);                    return;                }            }        }        if (p.padre.izquierdo == p){            t=a.derecho;            if (getColor(t)==Color.ROJO) {                if (t != null) {                    setColor(p, Color.NEGRO);                    setColor(t, Color.NEGRO);                    setColor(a, Color.ROJO);                    balanceaAgrega(a);                    return;                }            }        }        //caso 4: v y p están cruzados        if(a.derecho==p && p.izquierdo==v){            super.giraDerecha(p);            Vertice aux=v;            v=p;            p=aux;            a=v.padre.padre;        }        if(a.izquierdo==p && p.derecho==v){            super.giraIzquierda(p);            Vertice aux=v;            v=p;            p=aux;            a=v.padre.padre;        }        //caso 5: v y p no están cruzados        setColor(a,Color.ROJO);        setColor(p,Color.NEGRO);        if(a.derecho==p ) {//            setColor(p,Color.NEGRO);//            setColor(a,Color.ROJO);            super.giraIzquierda(a);            return;        }        else if(a.izquierdo==p ){//            setColor(p,Color.NEGRO);//            setColor(a,Color.ROJO);            super.giraDerecha(a);            return;        }    }    public Vertice getHermano(Vertice v){        if(v.padre.izquierdo==null){            return v.padre.derecho;        }        return v.padre.izquierdo;    }    @Override    public boolean elimina(T elemento){        // Aquí va su código.        if (super.busca(elemento) != null) {//            caso 3: El vértice a eliminar tiene 2 hijos            if (super.busca(elemento).derecho != null && super.busca(elemento).izquierdo != null) {                Vertice aux = super.busca(elemento).derecho;                Vertice masIzquierdo = super.buscaIzquierdo(aux);                super.busca(elemento).elemento = masIzquierdo.elemento;                if (masIzquierdo.derecho == null) {                    //caso 1 en caso 3                    masIzquierdo.padre.izquierdo = null;                    masIzquierdo.padre = null;                    elementos--;                    return true;                }                if (masIzquierdo.derecho != null) {                    //caso 2 en caso 3                    masIzquierdo.derecho.padre = masIzquierdo.padre;                    masIzquierdo.padre.izquierdo = masIzquierdo.derecho;                    elementos--;                    return true;                }            }//          caso 1: Que no tenga hijos el elemento a eliminar            if (super.busca(elemento).izquierdo == null && super.busca(elemento).derecho == null) {                Vertice fantasma = new Vertice(null);                setColor(fantasma,Color.NEGRO);                fantasma.padre=super.busca(elemento);                super.busca(elemento).izquierdo.padre = super.busca(elemento).padre;                super.busca(elemento).padre.izquierdo = super.busca(elemento).izquierdo;                elementos--;            }            Vertice h;//          caso 2: El vértice a eliminar tiene un solo hijo            if (super.busca(elemento).derecho == null && super.busca(elemento).izquierdo != null) {                super.busca(elemento).izquierdo.padre = super.busca(elemento).padre;                super.busca(elemento).padre.izquierdo = super.busca(elemento).izquierdo;                elementos--;                h=new Vertice(busca(elemento).izquierdo.elemento);                if (getColor(h)==Color.ROJO) {                    setColor(h, Color.NEGRO);                    return true;                }                if(getColor(busca(elemento))==Color.ROJO)                    return true;                if(getColor(busca(elemento))==Color.NEGRO && getColor(h)==Color.NEGRO) {                    balanceaElimina(h);                    if(h.elemento==null)                        elimina(h.elemento);                    return true;                }            }            if (super.busca(elemento).izquierdo == null && super.busca(elemento).derecho != null) {                super.busca(elemento).derecho.padre = super.busca(elemento).padre;                super.busca(elemento).padre.derecho = super.busca(elemento).derecho;                elementos--;                h=new Vertice(busca(elemento).derecho.elemento);                if (getColor(h)==Color.ROJO) {                    setColor(h, Color.NEGRO);                    return true;                }                if(getColor(busca(elemento))==Color.ROJO)                    return true;                if(getColor(busca(elemento))==Color.NEGRO && getColor(h)==Color.NEGRO) {                    balanceaElimina(h);                    if(h.elemento==null)                        elimina(h.elemento);                    return true;                }            }            //caso 1: Que no tenga hijos el elemento a eliminar//            if (super.busca(elemento).izquierdo == null && super.busca(elemento).derecho == null) {//                super.busca(elemento).padre = null;//                elementos--;//                return true;//            }////            //caso 2: El vértice a eliminar tiene un solo hijo//            if (super.busca(elemento).derecho == null && super.busca(elemento).izquierdo != null) {//                super.busca(elemento).izquierdo.padre = super.busca(elemento).padre;//                super.busca(elemento).padre.izquierdo = super.busca(elemento).izquierdo;//                elementos--;//                return true;//            }//            if (super.busca(elemento).izquierdo == null && super.busca(elemento).derecho != null) {//                super.busca(elemento).derecho.padre = super.busca(elemento).padre;//                super.busca(elemento).padre.derecho = super.busca(elemento).derecho;//                elementos--;//                return true;//            }////            //caso 3: El vértice a eliminar tiene 2 hijos//            if (super.busca(elemento).derecho != null && super.busca(elemento).izquierdo != null) {//                Vertice aux = super.busca(elemento).derecho;//                Vertice masIzquierdo = super.buscaIzquierdo(aux);//                super.busca(elemento).elemento=masIzquierdo.elemento;//                if (masIzquierdo.derecho == null) {//                    //caso 1 en caso 3//                    masIzquierdo.padre.izquierdo=null;//                    masIzquierdo.padre=null;//                    elementos--;//                    return true;//                }////                if (masIzquierdo.derecho != null) {//                    //caso 2 en caso 3//                    masIzquierdo.derecho.padre=masIzquierdo.padre;//                    masIzquierdo.padre.izquierdo=masIzquierdo.derecho;//                    elementos--;//                    return true;//                }////            }        }        return false;    }    public void balanceaElimina(Vertice v){        //caso 1        if(v==raiz){            return;        }        //caso 2        Vertice p = v.padre;        Vertice h = this.getHermano(v);        if(this.getColor(h)==Color.ROJO){            setColor(h, Color.NEGRO);            setColor(p, Color.ROJO);            if(v.padre.derecho==v){                super.giraDerecha(v);            }            super.giraIzquierda(v);            p = v.padre;            h=this.getHermano(v);        }        //caso 3        Vertice sobh = h.izquierdo;        Vertice sobd = h.derecho;        if(this.getColor(h)==Color.NEGRO && this.getColor(sobd)==Color.NEGRO && this.getColor(sobh)==Color.NEGRO){            if(this.getColor(p)==Color.NEGRO){                setColor(h,Color.ROJO);                this.balanceaElimina(p);                return;            }            //caso 4            setColor(p, Color.NEGRO);            setColor(h, Color.ROJO);            return;        }        //caso 5        if((v.padre.izquierdo==v && getColor(sobh)==Color.ROJO && getColor(sobd)==Color.NEGRO) || (v.padre.derecho==v && getColor(sobh)==Color.NEGRO && getColor(sobd)==Color.ROJO)){            if(this.getColor(sobh)==Color.ROJO){                setColor(sobh, Color.NEGRO);            }            setColor(sobd, Color.NEGRO);            setColor(h, Color.ROJO);            if(v.padre.izquierdo==v){                super.giraDerecha(v);            }            super.giraIzquierda(v);            h = this.getHermano(v);            sobh = h.izquierdo;            sobd = h.derecho;        }        //caso 6        if(getColor(p)==Color.NEGRO){            setColor(h, Color.NEGRO);        }        setColor(h, Color.ROJO);        setColor(p, Color.NEGRO);        if(v.padre.izquierdo==v){            setColor(sobd, Color.NEGRO);        }        setColor(sobh, Color.NEGRO);        if(v.padre.izquierdo==v){            super.giraIzquierda(p);        }        super.giraDerecha(p);    }    private boolean esRojo(Vertice v){        return getColor(v) == Color.ROJO;    }    /**     * Lanza la excepción {@link UnsupportedOperationException}: los árboles rojinegros no pueden ser girados por los     * usuarios de la clase.     * @param vertice el vértice sobre el que se quiere girar.     * @throws UnsupportedOperationException Siempre.     */    @Override    public void giraIzquierda(Vertice vertice) {        throw new UnsupportedOperationException();    }    /**     * Lanza la excepción {@link UnsupportedOperationException}: los árboles rojinegros no pueden ser girados por los     * usuarios de la clase.     * @param vertice el vértice sobre el que se quiere girar.     * @throws UnsupportedOperationException Siempre.     */    @Override    public void giraDerecha(Vertice vertice) {        throw new UnsupportedOperationException();    }    public static void main (String[]args){        Character [] arr= {'k','h','b','a','f','c','x','n','d','e'};        ArbolRojinegro<Character> arbol=new ArbolRojinegro<>(arr);//        arbol.imprimeRojinegroColorInOrder();        arbol.bfs(f -> System.out.println(f));        arbol.agrega('g');        System.out.println();        arbol.bfs(f -> System.out.println(f));        System.out.println();        arbol.dfs(1,f -> System.out.println(f));        System.out.println(arbol.esRojo(arbol.busca('d')));        System.out.println(arbol.esRojo(arbol.busca('b')));        System.out.println(arbol.esRojo(arbol.busca('h')));        System.out.println(arbol.esRojo(arbol.busca('a')));        System.out.println(arbol.esRojo(arbol.busca('c')));        System.out.println(arbol.esRojo(arbol.busca('f')));        System.out.println(arbol.esRojo(arbol.busca('n')));        System.out.println(arbol.esRojo(arbol.busca('e')));        System.out.println(arbol.esRojo(arbol.busca('k')));        System.out.println(arbol.esRojo(arbol.busca('x')));        System.out.println(arbol.esRojo(arbol.busca('g')));//        arbol.giraIzquierda(arbol.busca('f'));        System.out.println();        arbol.elimina('d');        arbol.bfs(f -> System.out.println(f));        System.out.println(arbol.esRojo(arbol.busca('e')));        System.out.println(arbol.esRojo(arbol.busca('b')));        System.out.println(arbol.esRojo(arbol.busca('h')));        System.out.println(arbol.esRojo(arbol.busca('a')));        System.out.println(arbol.esRojo(arbol.busca('c')));        System.out.println(arbol.esRojo(arbol.busca('f')));        System.out.println(arbol.esRojo(arbol.busca('n')));        System.out.println(arbol.esRojo(arbol.busca('g')));        System.out.println(arbol.esRojo(arbol.busca('k')));        System.out.println(arbol.esRojo(arbol.busca('x')));//        System.out.println(arbol.esRojo(arbol.busca('g')));    }}