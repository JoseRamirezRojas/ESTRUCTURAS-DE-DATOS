package practica6;/** * Implementación de árboles rojinegros. */public class ArbolRojinegro<T extends Comparable<T>> extends ArbolBinarioBusqueda<T>{    protected class VerticeRojinegro extends Vertice{        public VerticeRojinegro(T elemento){            // Aquí va su código.            super(elemento);            if(elemento==null){                this.color=color.NEGRO;            }            this.color= color.ROJO;        }        public Color color;    }    public ArbolRojinegro(){        // Aquí va su código.    }    public ArbolRojinegro(T[] a){        // Aquí va su código.    }    protected Color getColor(Vertice v){        // Aquí va su código.    }    protected void setColor(Vertice v, Color c){        // Aquí va su código.    }    /**     * Algoritmo recursivo para balancear un árbol rojinegro al agregarle un vértice     * @param v  Vértice agreado al árbol     */    public void balanceaAgrega(VerticeRojinegro v) {        v.color = Color.ROJO;        VerticeRojinegro a=new VerticeRojinegro (v.padre.padre.elemento);        VerticeRojinegro p=new VerticeRojinegro(v.padre.elemento);        VerticeRojinegro t;        if (p == null){            //caso 1: El vértice no tiene padre            v.color = Color.NEGRO;            return;        }        if (getColor(p)==Color.NEGRO)            //caso 2: El padre es negro            return;        if (getColor(p)==Color.NEGRO){            //caso 3: El tío es rojo            if (a.derecho == v.padre){                t=new VerticeRojinegro(a.izquierdo.elemento) ;                setColor(v.padre,Color.NEGRO);                setColor(t,Color.NEGRO);                setColor(v.padre.padre,Color.ROJO);                balanceaAgrega(a);                return;            }            if (a.izquierdo == v.padre){                t=new VerticeRojinegro(a.derecho.elemento) ;                setColor(v.padre,Color.NEGRO);                setColor(t,Color.NEGRO);                setColor(v.padre.padre,Color.ROJO);                balanceaAgrega(a);                return;            }            //caso 4: v y p están cruzados            if(a.derecho==p && p.izquierdo==v){               giraDerecha(p);               VerticeRojinegro aux=new VerticeRojinegro(v.elemento);               v=p;               p=aux;            }            if(a.izquierdo==p && p.derecho==v){                giraIzquierda(p);                VerticeRojinegro aux=new VerticeRojinegro(v.elemento);                v=p;                p=aux;            }            //caso 5: v y p no están cruzados            if(a.derecho==p && p.derecho==v) {                setColor(p,Color.NEGRO);                setColor(a,Color.ROJO);                giraIzquierda(a);                return;            }            setColor(p,Color.NEGRO);            setColor(a,Color.ROJO);            giraDerecha(a);            return;        }    }    @Override    public void agrega(T elemento){        VerticeRojinegro v=new VerticeRojinegro(elemento);        super.agrega(elemento);        balanceaAgrega(v);    }    @Override    public boolean elimina(T elemento){        // Aquí va su código.    }}